<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Market Data Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); border-left-color: #3b82f6; border-radius: 50%; width: 1rem; height: 1rem; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body class="text-gray-800">
    <div id="app" class="container mx-auto p-4 max-w-7xl">
        <h1 class="text-3xl font-bold mb-2 text-gray-900">Live Market Visualizer</h1>
        <h2 id="symbol-header" class="text-xl font-semibold text-blue-600 mb-6">No Symbol Selected</h2>

        <div class="bg-white p-4 rounded-lg shadow-lg mb-6">
            <div class="grid grid-cols-1 md:grid-cols-5 gap-4 items-end">
                <div>
                    <label for="security-select" class="block text-sm font-medium text-gray-700">Select Security</label>
                    <select id="security-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 rounded-md">
                        <option value="" disabled selected>-- Loading --</option>
                    </select>
                </div>
                <div>
                    <label for="interval-input" class="block text-sm font-medium text-gray-700">Candle Interval</label>
                    <select id="interval-input" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 rounded-md">
                        <option value="10000">10 Seconds</option>
                        <option value="60000" selected>1 Minute</option>
                        <option value="300000">5 Minutes</option>
                    </select>
                </div>
                <div>
                    <label for="bubble-threshold" class="block text-sm font-medium text-gray-700">Bubble Threshold</label>
                    <input type="number" id="bubble-threshold" value="20" class="mt-1 block w-full pl-3 pr-3 py-2 text-base border-gray-300 rounded-md">
                </div>
                <div>
                    <label for="big-player-qty" class="block text-sm font-medium text-gray-700">Big Player Qty</label>
                    <input type="number" id="big-player-qty" value="50" class="mt-1 block w-full pl-3 pr-3 py-2 text-base border-gray-300 rounded-md">
                </div>
                <div class="flex items-center justify-self-end space-x-4">
                    <div id="status-indicator" class="flex items-center space-x-2">
                        <div class="spinner"></div>
                        <span id="status-text" class="text-sm font-medium text-gray-600">Connecting...</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="bg-white p-4 rounded-lg shadow-lg">
            <div id="trading-chart" style="width: 100%; height: 65vh;"></div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const securitySelect = document.getElementById('security-select');
        const intervalInput = document.getElementById('interval-input');
        const bubbleThresholdInput = document.getElementById('bubble-threshold');
        const bigPlayerQtyInput = document.getElementById('big-player-qty');
        const statusText = document.getElementById('status-text');
        const spinner = document.querySelector('.spinner');
        const chartContainer = document.getElementById('trading-chart');

        // --- Global State ---
        let tradingChart = null;
        let socket = null;
        let currentSymbol = null;

        // chartState holds all the data required for rendering and updates.
        // It's reset whenever a new symbol is selected or a full redraw is needed.
        const chartState = {
            rawTicks: [],
            tradesByTime: new Map(), // For efficient bubble calculation
            lastTradePrice: 0,
            ohlcData: [],
            normalBuyVol: [],
            bigBuyVol: [],
            normalSellVol: [],
            bigSellVol: [],
            bubbleData: []
        };

        // --- Core Functions ---
        const updateStatus = (text, isLoading = false) => {
            statusText.textContent = text;
            spinner.style.display = isLoading ? 'block' : 'none';
        };

        const resetChartState = () => {
            chartState.rawTicks = [];
            chartState.tradesByTime.clear();
            chartState.lastTradePrice = 0;
            chartState.ohlcData = [];
            chartState.normalBuyVol = [];
            chartState.bigBuyVol = [];
            chartState.normalSellVol = [];
            chartState.bigSellVol = [];
            chartState.bubbleData = [];
        };

        // --- Data Processing Functions ---

        /**
         * Recalculates only the bubble data based on the current threshold.
         * This function is optimized to use the pre-aggregated `tradesByTime` map.
         */
        function updateBubbleSeries() {
            console.log("Updating bubble series with new threshold...");
            const bubbleThreshold = parseInt(bubbleThresholdInput.value, 10);
            const newBubbleData = [];

            chartState.tradesByTime.forEach((group, timeMs) => {
                if (group.sumLtq >= bubbleThreshold) {
                    newBubbleData.push([timeMs, group.price, group.sumLtq]);
                }
            });

            chartState.bubbleData = newBubbleData;
            tradingChart.setOption({ series: [{ id: 'bubbles', data: chartState.bubbleData }] });
        }

        /**
         * Processes the entire dataset to build all chart series from scratch.
         * This is called on initial load or when a setting (like interval) changes.
         */
        function processAndDrawAll() {
            if (chartState.rawTicks.length === 0) {
                updateStatus(`No historical data for ${currentSymbol}. Waiting for live feed.`, false);
                return;
            }
            console.log(`Full reprocessing of ${chartState.rawTicks.length} ticks.`);

            const intervalMs = parseInt(intervalInput.value, 10);
            const bigPlayerThreshold = parseInt(bigPlayerQtyInput.value, 10);
            const bubbleThreshold = parseInt(bubbleThresholdInput.value, 10);

            // Reset all data arrays
            resetChartState();
            const localRawTicks = [...chartState.rawTicks]; // Work on a copy
            chartState.rawTicks = localRawTicks; // Put it back after reset

            const buckets = new Map();

            chartState.rawTicks.forEach(tick => {
                const timeMs = parseInt(tick.ltt, 10);
                if (isNaN(timeMs)) return;

                // --- OHLCV Aggregation ---
                const intervalStartMs = Math.floor(timeMs / intervalMs) * intervalMs;
                if (!buckets.has(intervalStartMs)) {
                    buckets.set(intervalStartMs, {
                        time: intervalStartMs, open: tick.ltp, high: tick.ltp, low: tick.ltp, close: tick.ltp,
                        buyVolume: 0, bigPlayerBuyVolume: 0, sellVolume: 0, bigPlayerSellVolume: 0
                    });
                }
                const bucket = buckets.get(intervalStartMs);
                bucket.high = Math.max(bucket.high, tick.ltp);
                bucket.low = Math.min(bucket.low, tick.ltp);
                bucket.close = tick.ltp;

                const aggressor = chartState.lastTradePrice === 0 ? 'HOLD' : tick.ltp > chartState.lastTradePrice ? 'BUY' : 'SELL';
                chartState.lastTradePrice = tick.ltp;

                if (aggressor === 'BUY') {
                    if (tick.ltq >= bigPlayerThreshold) bucket.bigPlayerBuyVolume += tick.ltq;
                    else bucket.buyVolume += tick.ltq;
                } else if (aggressor === 'SELL') {
                    if (tick.ltq >= bigPlayerThreshold) bucket.bigPlayerSellVolume += tick.ltq;
                    else bucket.sellVolume += tick.ltq;
                }

                // --- Bubble Data Preparation ---
                if (!chartState.tradesByTime.has(timeMs)) {
                    chartState.tradesByTime.set(timeMs, { sumLtq: 0, price: tick.ltp });
                }
                chartState.tradesByTime.get(timeMs).sumLtq += tick.ltq;
            });

            // --- Bubble Processing ---
            chartState.tradesByTime.forEach((group, timeMs) => {
                if (group.sumLtq >= bubbleThreshold) {
                    chartState.bubbleData.push([timeMs, group.price, group.sumLtq]);
                }
            });

            const sortedBuckets = Array.from(buckets.values()).sort((a, b) => a.time - b.time);
            sortedBuckets.forEach(b => {
                chartState.ohlcData.push([b.time, b.open, b.close, b.low, b.high]);
                chartState.normalBuyVol.push([b.time, b.buyVolume]);
                chartState.bigBuyVol.push([b.time, b.bigPlayerBuyVolume]);
                chartState.normalSellVol.push([b.time, -b.sellVolume]);
                chartState.bigSellVol.push([b.time, -b.bigPlayerSellVolume]);
            });

            tradingChart.setOption({
                series: [
                    { id: 'ohlc', data: chartState.ohlcData },
                    { id: 'bubbles', data: chartState.bubbleData },
                    { id: 'normalBuy', data: chartState.normalBuyVol },
                    { id: 'bigBuy', data: chartState.bigBuyVol },
                    { id: 'normalSell', data: chartState.normalSellVol },
                    { id: 'bigSell', data: chartState.bigSellVol }
                ]
            }, { notMerge: true }); // Use notMerge to clear old data
            updateStatus(`Live: ${currentSymbol}`, false);
        };

        /**
         * Processes a single live tick incrementally, updating the chart without a full redraw.
         */
        function processLiveTick(tick) {
            const intervalMs = parseInt(intervalInput.value, 10);
            const bigPlayerThreshold = parseInt(bigPlayerQtyInput.value, 10);
            const bubbleThreshold = parseInt(bubbleThresholdInput.value, 10);
            const timeMs = parseInt(tick.ltt, 10);
            if (isNaN(timeMs)) return;

            chartState.rawTicks.push(tick);

            // --- Update OHLCV ---
            const intervalStartMs = Math.floor(timeMs / intervalMs) * intervalMs;
            let lastOhlc = chartState.ohlcData[chartState.ohlcData.length - 1];

            if (lastOhlc && lastOhlc[0] === intervalStartMs) {
                // Update the last candle
                lastOhlc[2] = tick.ltp; // Close
                lastOhlc[4] = Math.max(lastOhlc[4], tick.ltp); // High
                lastOhlc[3] = Math.min(lastOhlc[3], tick.ltp); // Low
            } else {
                // Create a new candle
                lastOhlc = [intervalStartMs, tick.ltp, tick.ltp, tick.ltp, tick.ltp];
                chartState.ohlcData.push(lastOhlc);
                // Also add new points for volume bars to keep them in sync
                chartState.normalBuyVol.push([intervalStartMs, 0]);
                chartState.bigBuyVol.push([intervalStartMs, 0]);
                chartState.normalSellVol.push([intervalStartMs, 0]);
                chartState.bigSellVol.push([intervalStartMs, 0]);
            }

            // --- Update Volume ---
            const aggressor = chartState.lastTradePrice === 0 ? 'HOLD' : tick.ltp > chartState.lastTradePrice ? 'BUY' : 'SELL';
            chartState.lastTradePrice = tick.ltp;

            if (aggressor === 'BUY') {
                if (tick.ltq >= bigPlayerThreshold) {
                    const vol = chartState.bigBuyVol[chartState.bigBuyVol.length - 1];
                    vol[1] += tick.ltq;
                } else {
                    const vol = chartState.normalBuyVol[chartState.normalBuyVol.length - 1];
                    vol[1] += tick.ltq;
                }
            } else if (aggressor === 'SELL') {
                if (tick.ltq >= bigPlayerThreshold) {
                    const vol = chartState.bigSellVol[chartState.bigSellVol.length - 1];
                    vol[1] -= tick.ltq;
                } else {
                    const vol = chartState.normalSellVol[chartState.normalSellVol.length - 1];
                    vol[1] -= tick.ltq;
                }
            }

            // --- Update Bubbles ---
            if (!chartState.tradesByTime.has(timeMs)) {
                chartState.tradesByTime.set(timeMs, { sumLtq: 0, price: tick.ltp });
            }
            const tradeGroup = chartState.tradesByTime.get(timeMs);
            const oldSumLtq = tradeGroup.sumLtq;
            tradeGroup.sumLtq += tick.ltq;

            if (tradeGroup.sumLtq >= bubbleThreshold && oldSumLtq < bubbleThreshold) {
                // A new bubble is born
                chartState.bubbleData.push([timeMs, tradeGroup.price, tradeGroup.sumLtq]);
            }

            // --- Update Chart ---
            // Let ECharts efficiently update the data without a full redraw
            tradingChart.setOption({
                series: [
                    { id: 'ohlc', data: chartState.ohlcData },
                    { id: 'bubbles', data: chartState.bubbleData },
                    { id: 'normalBuy', data: chartState.normalBuyVol },
                    { id: 'bigBuy', data: chartState.bigBuyVol },
                    { id: 'normalSell', data: chartState.normalSellVol },
                    { id: 'bigSell', data: chartState.bigSellVol }
                ]
            });
        }


        // --- ECharts Visualization ---
        const initChart = () => {
            if (tradingChart) tradingChart.dispose();
            tradingChart = echarts.init(chartContainer);
            tradingChart.setOption({
                animation: false,
                tooltip: { trigger: 'axis', axisPointer: { type: 'cross' } },
                axisPointer: { link: [{ xAxisIndex: 'all' }] },
                grid: [{ bottom: '32%', right: '8%', left: '8%' }, { top: '72%', height: '16%', right: '8%', left: '8%' }],
                xAxis: [
                    { type: 'time', scale: true, axisLine: { onZero: false }, splitLine: { show: false }, axisLabel: { show: false } },
                    { type: 'time', gridIndex: 1, scale: true, axisLine: { onZero: false }, splitLine: { show: false } }
                ],
                yAxis: [{ scale: true }, { gridIndex: 1, scale: true, splitNumber: 2, axisLabel: { show: false } }],
                dataZoom: [
                    { type: 'inside', xAxisIndex: [0, 1], start: 95, end: 100 },
                    { show: true, xAxisIndex: [0, 1], type: 'slider', top: '90%', start: 95, end: 100 }
                ],
                series: [
                    { id: 'ohlc', name: 'Candlestick', type: 'candlestick', data: [], itemStyle: { color: '#22c55e', color0: '#ef4444', borderColor: '#16a34a', borderColor0: '#dc2626' } },
                    { id: 'bubbles', name: 'Volume Bubble', type: 'scatter', data: [], symbolSize: data => Math.min(50, Math.max(5, Math.log(data[2] + 1) * 2)) },
                    { id: 'normalBuy', name: 'Normal Buy', type: 'bar', xAxisIndex: 1, yAxisIndex: 1, data: [], stack: 'Vol', itemStyle: { color: '#86efac'} },
                    { id: 'bigBuy', name: 'Big Buy', type: 'bar', xAxisIndex: 1, yAxisIndex: 1, data: [], stack: 'Vol', itemStyle: { color: '#22c55e'} },
                    { id: 'normalSell', name: 'Normal Sell', type: 'bar', xAxisIndex: 1, yAxisIndex: 1, data: [], stack: 'Vol', itemStyle: { color: '#fca5a5'} },
                    { id: 'bigSell', name: 'Big Sell', type: 'bar', xAxisIndex: 1, yAxisIndex: 1, data: [], stack: 'Vol', itemStyle: { color: '#ef4444'} }
                ]
            });
        };

        // --- WebSocket Connection & Logic ---
        const connectSocket = () => {
            if (socket) socket.disconnect();
            socket = io('/bubble');

            socket.on('connect', () => {
                updateStatus('Connected. Requesting data...', true);
                if (currentSymbol) {
                    socket.emit('request_initial_data', { symbol: currentSymbol });
                }
            });

            socket.on('disconnect', () => updateStatus('Disconnected.', false));

            socket.on('available_securities', (data) => {
                const selectedValue = securitySelect.value;
                securitySelect.innerHTML = '<option value="" disabled selected>-- Select a Security --</option>';
                data.securities.forEach(id => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = id;
                    securitySelect.appendChild(option);
                });
                // Restore selection if possible
                if (data.securities.includes(selectedValue)) {
                    securitySelect.value = selectedValue;
                }
            });

            socket.on('historical_ticks', (msg) => {
                if (msg.securityId !== currentSymbol) return;
                resetChartState();
                chartState.rawTicks = msg.ticks;
                processAndDrawAll();
            });

            socket.on('live_tick', (msg) => {
                if (msg.securityId !== currentSymbol || !msg.tick) return;
                processLiveTick(msg.tick);
            });
        };

        // --- Event Handlers ---
        securitySelect.addEventListener('change', () => {
            currentSymbol = securitySelect.value;
            if (!currentSymbol) return;
            document.getElementById('symbol-header').textContent = `Symbol: ${currentSymbol}`;
            initChart(); // Clear the previous chart
            resetChartState();
            updateStatus(`Fetching data for ${currentSymbol}...`, true);
            // Re-request data for the new symbol
            if (socket && socket.connected) {
                socket.emit('request_initial_data', { symbol: currentSymbol });
            }
        });

        intervalInput.addEventListener('change', processAndDrawAll);
        bigPlayerQtyInput.addEventListener('change', processAndDrawAll);
        bubbleThresholdInput.addEventListener('change', updateBubbleSeries);

        window.addEventListener('resize', () => tradingChart?.resize());

        // --- Initialization ---
        window.onload = () => {
            initChart();
            connectSocket();
        };
    </script>
</body>
</html>